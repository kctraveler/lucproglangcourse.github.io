- business and software engineering contexts (1 week)

  - software requirements

    - functional requirements
    - nonfunctional requirements

  - development process

    - testing
    - refactoring
    - automation

  - design principles and patterns

    - separation of concerns
    - parametricity
    - SOLID
    - GoF/POSA

- imperative and object-oriented programming (2 weeks)

  - console applications
  - constant-space complexity
  - logging
  - domain modeling
  - using traits for modularity and dependency injection


- functional programming (4 weeks)

  - defining algebraic data types

    - scalars: enumerations
    - sublinear structures: numbers, option
    - linear structures: lists, maps
    - nonlinear structures: trees

  - implementing behaviors on algebraic data types

    - pattern matching
    - recursion

  - higher-order functions
  - predefined types and their behaviors
  - recursion patterns
  - higher-kinded types

- programming language representation and interpretation/execution (4 weeks)

  - language design space
  - scanners (lexical analyzers)
  - parsers (syntax analyzers)
  - interpreters and compilers
  - domain-specific languages

- concurrent and parallel programming (3 weeks)

  - parallel collections
  - futures and promises
  - progress reporting and cancelation
  - asynchronous programming/reactive extensions (Rx)
  - advanced mechanisms

    - explicit threads
    - actors
    - software-transactional memory
    - task-parallel library
    - functional data structures
